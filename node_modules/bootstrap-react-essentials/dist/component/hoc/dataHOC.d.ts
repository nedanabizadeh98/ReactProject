import { RouteComponentProps } from "react-router";
import { StrictOmit } from "ts-essentials";
import defaultRepository from "../../repository/dataRepository";
import { appendURLQuery as defaultAppendURLQuery } from "../../utils";
export interface URLDataSyncInProps<Data> extends Pick<RouteComponentProps<any>, "history" | "location"> {
    readonly data: Data | undefined;
    readonly dataError: Error | undefined;
    readonly isLoadingData: boolean;
    /**
     * Specify the query parameter keys to observe. Only the values for these
     * keys are changed do we force a refetch. Leave undefined if we want all
     * keys to be observed, or an empty array if we do not want any key to be
     * observed.
     */
    readonly queryParametersToWatch?: readonly string[];
    getData(): void;
    onDataSynchronized?(newData: Partial<Data>): void;
    onDataErrorEncountered?(error: Error): void;
    setData(data?: Partial<Data>): void;
    setDataError(error?: Error): void;
    setIsLoadingData(isLoadingData?: boolean): void;
    saveData(): void;
    updateData(data: Partial<Data>): void;
}
export interface URLDataSyncOutProps<Data> extends Pick<URLDataSyncInProps<Data>, "history" | "location" | "onDataErrorEncountered" | "onDataSynchronized" | "queryParametersToWatch"> {
    overrideConfiguration?: HTTPClient.Config;
    syncRepository?: typeof defaultRepository;
}
/**
 * Automatically sync with current URL by requesting data from server using
 * said URL. This is assuming there is data provided by the server at current
 * URL, e.g. user navigates to /users/1, this will send a GET request to
 * /users/1, which should have a defined backend route that contains the
 * relevant data.
 *
 * This HOC is usually used for components rendered by a Route. Please make sure
 * when implementing the backend to handle these requests that it never returns
 * null/undefined (as per REST design standards).
 */
export declare function urlDataSyncHOC<Data>(syncRepository?: typeof defaultRepository, overrideConfig?: URLDataSyncOutProps<Data>["overrideConfiguration"], queryParamsToObserve?: URLDataSyncOutProps<Data>["queryParametersToWatch"]): FunctionalEnhancer<URLDataSyncInProps<Data>, URLDataSyncOutProps<Data>>;
export interface CursorPaginatedData<T> {
    readonly results: readonly T[];
    readonly limit?: number;
    readonly order?: string;
    readonly sortField?: Extract<keyof T, string>;
    readonly next?: string;
    readonly previous?: string;
    readonly hasNext?: boolean;
    readonly hasPrevious?: boolean;
}
export interface URLCursorPaginatedSyncInProps<T> extends StrictOmit<URLDataSyncInProps<readonly T[]>, "data">, Pick<CursorPaginatedData<T>, "hasNext" | "hasPrevious" | "limit" | "order" | "sortField"> {
    readonly data: readonly T[];
    goToNextPage(): void;
    goToPreviousPage(): void;
}
export interface URLCursorPaginatedSyncOutProps<T> extends URLDataSyncOutProps<readonly T[]> {
}
/**
 * This HOC automatically manages pagination data sync, and is best used to
 * display table data. For other kinds of data use the data sync HOC.
 */
export declare function urlCursorPaginatedSyncHOC<T>(syncRepository?: typeof defaultRepository, overrideConfig?: URLDataSyncOutProps<T>["overrideConfiguration"], appendURLQuery?: typeof defaultAppendURLQuery): FunctionalEnhancer<URLCursorPaginatedSyncInProps<T>, URLCursorPaginatedSyncOutProps<T>>;
//# sourceMappingURL=dataHOC.d.ts.map